using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Bio;
using Bio.IO.FastA;
using Common;
using MPI;
using Salsa.Core;
using Salsa.Core.Blas;

#if USE_UINT16
using TDistance = System.UInt16;
#elif USE_INT16
using TDistance = System.Int16;
#else
using TDistance = System.Double;
#endif

namespace ScattersLargeScale
{
    class Program
    {
        private static string _aMat;
        private static string _bMat;
        private static int _size;
        private static string _outdir;

        private static bool _useTDistanceMax;

        static double _xmaxbound = 1.0;
        static double _ymaxbound = 1.0;
        static int _xres = 50;
        static int _yres = 50;
        static double _alpha = 2.0;
        static double _pcutf = 0.85;
        static bool _zto1 = true;

        static double _xmaxWhole = double.NegativeInfinity;
        static double _xminWhole = double.PositiveInfinity;
        static double _ymaxWhole = double.NegativeInfinity;
        static double _yminWhole = double.PositiveInfinity;

        static double _xmaxSelected = double.NegativeInfinity;
        static double _xminSelected = double.PositiveInfinity;
        static double _ymaxSelected = double.NegativeInfinity;
        static double _yminSelected = double.PositiveInfinity;

        static double _xmaxSelectedInter = double.NegativeInfinity;
        static double _xminSelectedInter = double.PositiveInfinity;
        static double _ymaxSelectedInter = double.NegativeInfinity;
        static double _yminSelectedInter = double.PositiveInfinity;

        private static int _aTransfm, _bTransfm;
        private static double _aTransfp, _bTransfp;
        private static double _distcut;


        private static double _deltaxWhole;
        private static double _deltayWhole;
        private static double _deltaxSelected;
        private static double _deltaySelected;
        private static double _deltaxSelectedInter;
        private static double _deltaySelectedInter;

        // Surface area of each small 2D square
        private static double _deltasWhole;
        private static double _deltasSelected;
        private static double _deltasSelectedInter;

        private static readonly HashSet<int> SelectedCnums = new HashSet<int>();
        private static readonly Hashtable PnumToCnum = new Hashtable();
        private static string _aName;
        private static string _bName;
        private static string _clusterfile;
        private static string _title;
        private static List<ISequence> _seqs = new List<ISequence>();
        private static double _lengthCut;
        private static bool _useClusters; // indicate if clustering data is available
        private static double[] _denomcuts;
        private static string _oldscoremat;
        private static string _newscoremat;
        private static bool _denomcutsenabled;


        static void Main(string[] args)
        {
            // Load the command line args into our helper class which allows us to name arguments
            Arguments pargs = new Arguments(args)
            {
                Usage = "Usage: ScatterLargeScale.exe /config=<string>"
            };

            if (pargs.CheckRequired(new[] { "config" }) == false)
            {
                Console.WriteLine(pargs.Usage);
                return;
            }

            using (new MPI.Environment(ref args))
            {
                ReadConfiguration(pargs);
                if (_useClusters)
                {
                    PopulatePnumToCnum();
                }

                int rank = Communicator.world.Rank;
                int worldSize = Communicator.world.Size;

//                for (int i = 0; i < _denomcuts.Length; i++)
                for (int i = 0; i < 2; i++)
                {
                    try
                    {
                        if (rank == 0) Console.WriteLine("Iteration " + i + " Rank 0 is just starting");
                        //                    double denormcut = _denomcuts[i];
                        double denormcut = i == 0 ? 0.1 : 0.25;


                        Block[][] processToCloumnBlocks = BlockPartitioner.Partition(_size, _size, worldSize, worldSize);
                        if (rank == 0) Console.WriteLine("Iteration " + i + " done creating processToCloumnBlocks");
                        Block[] myColumnBlocks = processToCloumnBlocks[rank];
                        if (rank == 0) Console.WriteLine("Iteration " + i + " done creating myColumnBlocks");

                        PartialMatrix<TDistance> myRowStripMatrixForA =
                            new PartialMatrix<TDistance>(myColumnBlocks[0].RowRange, new Range(0, _size - 1));
                        if (rank == 0) Console.WriteLine("Iteration " + i + " done creating myRowStripMatrixForA");
                        PartialMatrix<TDistance> myRowStripMatrixForB =
                            new PartialMatrix<TDistance>(myColumnBlocks[0].RowRange, new Range(0, _size - 1));
                        if (rank == 0) Console.WriteLine("Iteration " + i + " done creating myRowStripMatrixForB");
                        PartialMatrix<bool> myRowStripMatrixForDnormCut = new PartialMatrix<bool>(
                            myColumnBlocks[0].RowRange, new Range(0, _size - 1));
                        if (rank == 0)
                            Console.WriteLine("Iteration " + i + " done creating myRowStripMatrixForDnormCut");

                        if (rank == 0) Console.WriteLine("Iteration " + i + " Rank 0 is reading distance blocks");
                        ReadDistanceBlocks(rank, myRowStripMatrixForA, myRowStripMatrixForB, myColumnBlocks, denormcut,
                                           myRowStripMatrixForDnormCut);



                        // Wait till everyone is done reading their blocks and have local min and max values
                        //                    Communicator.world.Barrier();

                        if (rank == 0) Console.WriteLine("Iteration " + i + " All are done reading distance blocks");

                        _xminWhole = Communicator.world.Allreduce(_xminWhole, Operation<double>.Min);
                        _xmaxWhole = Communicator.world.Allreduce(_xmaxWhole, Operation<double>.Max);
                        _yminWhole = Communicator.world.Allreduce(_yminWhole, Operation<double>.Min);
                        _ymaxWhole = Communicator.world.Allreduce(_ymaxWhole, Operation<double>.Max);

                        if (_useClusters)
                        {
                            _xminSelected = Communicator.world.Allreduce(_xminSelected, Operation<double>.Min);
                            _xmaxSelected = Communicator.world.Allreduce(_xmaxSelected, Operation<double>.Max);
                            _yminSelected = Communicator.world.Allreduce(_yminSelected, Operation<double>.Min);
                            _ymaxSelected = Communicator.world.Allreduce(_ymaxSelected, Operation<double>.Max);

                            _xminSelectedInter = Communicator.world.Allreduce(_xminSelectedInter, Operation<double>.Min);
                            _xmaxSelectedInter = Communicator.world.Allreduce(_xmaxSelectedInter, Operation<double>.Max);
                            _yminSelectedInter = Communicator.world.Allreduce(_yminSelectedInter, Operation<double>.Min);
                            _ymaxSelectedInter = Communicator.world.Allreduce(_ymaxSelectedInter, Operation<double>.Max);
                        }

                        // Output min/max
                        if (rank == 0)
                        {
                            Console.WriteLine("Denomcut: {0}", denormcut);
                            Console.WriteLine("xmaxwhole:{0} xminwhole:{1} ymaxwhole:{2} yminwhole:{3}", _xmaxWhole,
                                              _xminWhole,
                                              _ymaxWhole, _yminWhole);
                            if (_useClusters)
                            {
                                Console.WriteLine("xmaxselected:{0} xminselected:{1} ymaxselected:{2} yminselected:{3}",
                                                  _xmaxSelected, _xminSelected, _ymaxSelected, _yminSelected);
                                Console.WriteLine(
                                    "xmaxselectedinter:{0} xminselectedinter:{1} ymaxselectedinter:{2} yminselectedinter:{3}",
                                    _xmaxSelectedInter, _xminSelectedInter, _ymaxSelectedInter, _yminSelectedInter);
                            }
                        }


                        // global xmax, xmin, ymax, and ymin should be set by now
                        _deltaxWhole = (_xmaxWhole - _xminWhole)/_xres;
                        _deltayWhole = (_ymaxWhole - _yminWhole)/_yres;
                        _deltasWhole = _deltaxWhole*_deltayWhole;

                        if (_useClusters)
                        {
                            _deltaxSelected = (_xmaxSelected - _xminSelected)/_xres;
                            _deltaySelected = (_ymaxSelected - _yminSelected)/_yres;
                            _deltasSelected = _deltaxSelected*_deltaySelected;

                            _deltaxSelectedInter = (_xmaxSelectedInter - _xminSelectedInter)/_xres;
                            _deltaySelectedInter = (_ymaxSelectedInter - _yminSelectedInter)/_yres;
                            _deltasSelectedInter = _deltaxSelectedInter*_deltaySelectedInter;
                        }

                        Hashtable cellsForWholeSample = new Hashtable();
                        Hashtable cellsForSelectedClusters = new Hashtable();
                        Hashtable cellsForSelectedClustersInter = new Hashtable();
                        GeneratePartialHistograms(cellsForWholeSample, cellsForSelectedClusters,
                                                  cellsForSelectedClustersInter,
                                                  rank, myRowStripMatrixForA, myRowStripMatrixForB, myColumnBlocks,
                                                  myRowStripMatrixForDnormCut);


                        // Wait till everyone is done their part of histogramming
                        //                    Communicator.world.Barrier(););
                        if (rank == 0)
                            Console.WriteLine("Iteration " + i + " All are done generating partial histograms");

                        Hashtable[] cellsArrayForWholeSample;
                        //                    Hashtable[] cellsArrayForWholeSample = new Hashtable[worldSize];
                        Hashtable[] cellsArrayForSelectedClusters = new Hashtable[worldSize];
                        Hashtable[] cellsArrayForSelectedClustersInter = new Hashtable[worldSize];

                        if (rank == 0) Console.WriteLine("Iteration " + i + " came here before gather");

                        cellsArrayForWholeSample = Communicator.world.Gather(cellsForWholeSample, 0);
                        //                    Communicator.world.Gather(cellsForWholeSample, 0, ref cellsArrayForWholeSample);

                        if (rank == 0) Console.WriteLine("Iteration " + i + " came here after gather");

                        // todo: remove after testing
                        //                    Communicator.world.Barrier();
                        continue;
                    
                    
                    if (_useClusters)
                    {
                        Communicator.world.Gather(cellsForSelectedClusters, 0, ref cellsArrayForSelectedClusters);
                        Communicator.world.Gather(cellsForSelectedClustersInter, 0,
                                                  ref cellsArrayForSelectedClustersInter);
                    }

                    

                    if (rank == 0)
                    {
                        // Rank 0 should have all the cells from each process by now.

                        Console.WriteLine("Rank 0 starting to write density data file for whole sample");
                        GenerateDensityDataFile(cellsArrayForWholeSample, _xmaxWhole, _xminWhole, _ymaxWhole, _yminWhole,
                                                _deltaxWhole, _deltayWhole, _deltasWhole, "whole", denormcut);
                        Console.WriteLine("Rank 0 done writing density data file for whole sample");

                        if (_useClusters)
                        {
                            Console.WriteLine("Rank 0 starting to write density data file for selected clusters");
                            GenerateDensityDataFile(cellsArrayForSelectedClusters, _xmaxSelected, _xminSelected,
                                                    _ymaxSelected,
                                                    _yminSelected, _deltaxSelected, _deltaySelected, _deltasSelected,
                                                    "selected", denormcut);
                            Console.WriteLine("Rank 0 done writing density data file for selected clusters");
                            Console.WriteLine("Rank 0 starting to write density data file for selected clusters inter");
                            GenerateDensityDataFile(cellsArrayForSelectedClustersInter, _xmaxSelectedInter,
                                                    _xminSelectedInter,
                                                    _ymaxSelectedInter, _yminSelectedInter, _deltaxSelectedInter,
                                                    _deltaySelectedInter, _deltasSelectedInter, "selected-inter", denormcut);
                            Console.WriteLine("Rank 0 done writing density data file for selected clusters inter");
                        }
                    }

                    Communicator.world.Barrier();
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Exception in rank " + rank + " in iteration " + i  + " " + e.Message);
                    }
                }
            }
        }

        private static void PopulatePnumToCnum()
        {
            using (StreamReader reader = new StreamReader(File.Open(_clusterfile, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                char[] sep = new[] {' ', '\t'};
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    if (!string.IsNullOrEmpty(line))
                    {
                        string[] splits = line.Split(sep);
                        int idx = int.Parse(splits[0]);
                        int cnum = int.Parse(splits[1]);
                        PnumToCnum[idx] = cnum;
                    }
                }
            }
        }


        private static void GenerateDensityDataFile(IEnumerable<Hashtable> cellsArray, double xmax, double xmin, double ymax, double ymin, 
            double deltax, double deltay, double deltas, string prefix, double denormcut)
        {
            Hashtable xHist = new Hashtable(_xres);
            Hashtable yHist = new Hashtable(_yres);

            long cellmax = 0, count = 0;
            Hashtable finalcells = new Hashtable();
            foreach (Hashtable t in cellsArray)
            {
                foreach (DictionaryEntry kv in t)
                {
                    string cell = (string)kv.Key;
                    string[] splits = cell.Split(',');
                    int cellx = int.Parse(splits[0]);
                    int celly = int.Parse(splits[1]);
                    long v = (long)kv.Value;
                    finalcells[cell] = finalcells.ContainsKey(cell) ? ((long)finalcells[cell]) + v : v;
                    xHist[cellx] = xHist.ContainsKey(cellx) ? ((long)xHist[cellx]) + v : v;
                    yHist[celly] = yHist.ContainsKey(celly) ? ((long)yHist[celly]) + v : v;
                    if ((long)finalcells[cell] > cellmax)
                    {
                        cellmax = (long)finalcells[cell];
                    }
                    count += v;
                }
            }

            double cellmean = ((double)count) / (_xres * _yres);
            double power = cellmax < (_alpha * cellmean) ? 1.0 : (Math.Log(_alpha) / Math.Log(cellmax / cellmean));
            // Constant value by which the number of points in a 2D square is multiplied.
            // The resulting value is independent of the total number of points as well as 
            // the x,y resolution. The mult value is a factor changing the z value scale.
            double c = _zto1 ? (1.0 / cellmax) : (1.0 / (count * deltas));

            // Output density values
            Console.WriteLine(new string('*',40));
            Console.WriteLine("DataSet\t" + prefix);
            Console.WriteLine("CellMean\t" + cellmean);
            Console.WriteLine("CellMax\t" + cellmax);
            Console.WriteLine("Power\t" + power);
            Console.WriteLine("Const\t" + c);
            for (int i = 0; i < 10; i++)
            {
                double density = i/10.0;
                double densityToCount = Math.Pow(density, (1/power))/c;
                Console.WriteLine(density +"\t" + densityToCount);
            }
            Console.WriteLine(new string('*',40));

            int xpointcount = 2 * _xres;
            int ypointcount = 2 * _yres;

            string aNameFinal = _aTransfm > -1 ? "Transformed-" + _aName : _aName;
            string bNameFinal = _bTransfm > -1 ? "Transformed-" + _bName : _bName;

            string dCutString = "DCut[" + (_distcut > -1 ? _distcut.ToString() : "none") + "]";
            string vsString = bNameFinal + "-Vs-" + aNameFinal;

            string dir = _outdir;
            if(_denomcutsenabled)
            {
                dir = Path.Combine(_outdir, "denormcut_" + denormcut.ToString());
                Directory.CreateDirectory(dir);
            }

            string densityFile = Path.Combine(dir, prefix + "-density-" + dCutString + "-" + vsString + ".txt");

            string xHistFile = Path.Combine(dir, prefix + "-xHist-" + dCutString + "-" + vsString + ".txt");

            string yHistFile = Path.Combine(dir, prefix + "-yHist-" + dCutString + "-" + vsString + ".txt");

            string gnuplotScriptFileLarge = Path.Combine(dir, prefix + "-gnuplot-" + dCutString + "-" + vsString + "-large.txt");
            string gnuplotScriptFileSmall = Path.Combine(dir, prefix + "-gnuplot-" + dCutString + "-" + vsString + "-small.txt");

            using (StreamWriter densityFileWriter = new StreamWriter(densityFile),
                xHistWriter = new StreamWriter(xHistFile), yHistWriter = new StreamWriter(yHistFile),
                gnuplotWriterLarge = new StreamWriter(gnuplotScriptFileLarge), gnuplotWriterSmall = new StreamWriter(gnuplotScriptFileSmall))
            {
                densityFileWriter.WriteLine("#xcoord\tycoord\thistogramValue");
                xHistWriter.WriteLine("#xval\thistogramvalue");
                yHistWriter.WriteLine("#yval\thistogramvalue");

                // Generating x histogram
                double xoffset = xmin + 0.5 * deltax;
                for (int i = 0; i < _xres; ++i)
                {
                    double xcoord = xoffset + i * deltax;
                    xHistWriter.WriteLine(xcoord + "\t" + (xHist.ContainsKey(i) ? xHist[i] : 0L));
                }

                // Generating y histogram
                double yoffset = ymin + 0.5 * deltay;
                for (int i = 0; i < _yres; ++i)
                {
                    double ycoord = yoffset + i * deltay;
                    yHistWriter.WriteLine(ycoord + "\t" + (yHist.ContainsKey(i) ? yHist[i] : 0L));
                }

                for (int i = 0; i < xpointcount; i++)
                {
                    double x = xmin + ((IsOdd(i) ? (i + 1) / 2 : i / 2) * deltax);
                    int cellx = IsOdd(i) ? (i - 1) / 2 : i / 2;

                    for (int j = 0; j < ypointcount; j++)
                    {
                        double y = ymin + ((IsOdd(j) ? (j + 1) / 2 : j / 2) * deltay);
                        int celly = IsOdd(j) ? (j - 1) / 2 : j / 2;
                        string cell = cellx + "," + celly;

                        double cellvalue = Math.Pow(((finalcells.ContainsKey(cell) ? (long)finalcells[cell] : 0L) * c), power);

                        // todo: commented for now
                        // cellvalue = cellvalue > pcutf ? pcutf : cellvalue < ncutf ? ncutf : cellvalue;
                        cellvalue = _pcutf > -1 && cellvalue > _pcutf ? _pcutf : cellvalue;

                        densityFileWriter.WriteLine(x + "\t" + y + "\t" + cellvalue);
                    }
                    densityFileWriter.WriteLine();
                }

                if (_xmaxbound == -1)
                {
                    _xmaxbound = xmax;
                }

                if (_ymaxbound == -1)
                {
                    _ymaxbound = ymax;
                }

                // Fill up the remaining region from beyond x=xmax and y=ymax as zero 
                densityFileWriter.WriteLine();
                densityFileWriter.WriteLine(xmin + "\t" + ymax + "\t" + 0.0);
                densityFileWriter.WriteLine(xmin + "\t" + _ymaxbound + "\t" + 0.0);
                densityFileWriter.WriteLine();
                densityFileWriter.WriteLine(xmax + "\t" + ymax + "\t" + 0.0);
                densityFileWriter.WriteLine(xmax + "\t" + _ymaxbound + "\t" + 0.0);
                densityFileWriter.WriteLine();
                densityFileWriter.WriteLine(xmax + "\t" + ymin + "\t" + 0.0);
                densityFileWriter.WriteLine(xmax + "\t" + _ymaxbound + "\t" + 0.0);
                densityFileWriter.WriteLine();
                densityFileWriter.WriteLine(_xmaxbound + "\t" + ymin + "\t" + 0.0);
                densityFileWriter.WriteLine(_xmaxbound + "\t" + _ymaxbound + "\t" + 0.0);

                
                /* Writing Gnuplot script */
                WriteGnuplotScript(bNameFinal, aNameFinal, prefix, vsString, densityFile, xHistFile, yHistFile, gnuplotWriterLarge, gnuplotWriterSmall, denormcut);
            }
        }

        private static void WriteGnuplotScript(string bNameFinal, string aNameFinal, string prefix, string vsString, 
            string densityFile, string xHistFile, string yHistFile, StreamWriter gnuplotWriterLarge, StreamWriter gnuplotWriterSmall, double denormcut)
        {

            gnuplotWriterLarge.WriteLine("set terminal png truecolor nocrop font arial 14 size 1200,1200 xffffff");
            gnuplotWriterSmall.WriteLine("set terminal png truecolor nocrop font arial 14 size 1000,500 xffffff");
            
            gnuplotWriterLarge.WriteLine();
            
            string pngfile = prefix + "-plot-" + vsString + "DensitySat[" + (_pcutf>-1?_pcutf.ToString():"none") + "]" + (_denomcutsenabled? "-DenormCut[" + denormcut + "]-" : "-") + "large.png";
            gnuplotWriterLarge.WriteLine("set output '" + pngfile + "'");
            pngfile = prefix + "-plot-" + vsString + "DensitySat[" + (_pcutf > -1 ? _pcutf.ToString() : "none") + "]" + (_denomcutsenabled ? "-DenormCut[" + denormcut + "]-" : "-") + "small.png";
            gnuplotWriterSmall.WriteLine("set output '" + pngfile + "'");

            gnuplotWriterLarge.WriteLine("set size 1.0, 1.0");
            gnuplotWriterLarge.WriteLine("set multiplot");
            gnuplotWriterSmall.WriteLine("set multiplot");

            gnuplotWriterLarge.WriteLine();
            gnuplotWriterSmall.WriteLine();

            // Title box
            gnuplotWriterLarge.WriteLine("set origin 0.0, 0.85");
//            gnuplotWriterSmall.WriteLine("set origin 0.0, 0.7");
            gnuplotWriterLarge.WriteLine("set size 0.95, 0.1");
//            gnuplotWriterSmall.WriteLine("set size 0.95, 0.1");
            gnuplotWriterLarge.WriteLine("set border linecolor rgbcolor \"white\"");
//            gnuplotWriterSmall.WriteLine("set border linecolor rgbcolor \"white\"");
            gnuplotWriterLarge.WriteLine("unset key");
//            gnuplotWriterSmall.WriteLine("unset key");
            string dcutString = _distcut > - 1 ? _distcut.ToString() : "none";
            string title = string.Format(_title, (_pcutf > -1 ? _pcutf.ToString() : "none"), bNameFinal, dcutString, aNameFinal, dcutString,
                                         (prefix.Equals("whole")
                                              ? "Whole Sample"
                                              : (prefix.Equals("selected")
                                                     ? "Selected Clusters Intra Pairs"
                                                     : "Selected Clusters Inter Pairs")));
            if (_denomcutsenabled)
            {
                title += "\nDenormCut[" + denormcut + "]";
            }
            gnuplotWriterLarge.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
//            gnuplotWriterSmall.WriteLine("set title \"" + title + "textcolor rgbcolor \"black\"");
            gnuplotWriterLarge.WriteLine("plot [0:1] [0:1] 0.0 lt rgb \"white\"");
//            gnuplotWriterSmall.WriteLine("plot [0:1] [0:1] 0.0 lt rgb \"white\"");

            gnuplotWriterLarge.WriteLine("set border linecolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set border linecolor rgbcolor \"black\"");

            gnuplotWriterLarge.WriteLine("set dummy u,v");
            gnuplotWriterSmall.WriteLine("set dummy u,v");
            
            gnuplotWriterLarge.WriteLine("unset key");
            gnuplotWriterSmall.WriteLine("unset key");
            
            gnuplotWriterLarge.WriteLine("set size ratio 1.0");
//            gnuplotWriterSmall.WriteLine("set size ratio 1.0");
            
            gnuplotWriterLarge.WriteLine("set style fill  solid 0.85 noborder");
            gnuplotWriterSmall.WriteLine("set style fill  solid 0.85 noborder");
            
            gnuplotWriterLarge.WriteLine("set style line 1 lt 1 lw 4");
            gnuplotWriterSmall.WriteLine("set style line 1 lt 1 lw 4");
            
            gnuplotWriterLarge.WriteLine("set pm3d map");
            gnuplotWriterSmall.WriteLine("set pm3d map");
            
            gnuplotWriterLarge.WriteLine("set palette rgbformulae 30,31,32 model RGB negative");
            gnuplotWriterSmall.WriteLine("set palette rgbformulae 30,31,32 model RGB negative");

            gnuplotWriterLarge.WriteLine();
            gnuplotWriterSmall.WriteLine();

            // Y histogram (rotated)
            gnuplotWriterLarge.WriteLine("set origin 0.0, 0.45");
            gnuplotWriterLarge.WriteLine("set size 0.45, 0.45");
            gnuplotWriterLarge.WriteLine("set xtics rotate by -90");
            string xlabel = "Count";
            gnuplotWriterLarge.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            string ylabel = bNameFinal;
            gnuplotWriterLarge.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            title = "Histogram (rotated) of " + bNameFinal + " distances";
            gnuplotWriterLarge.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterLarge.WriteLine("plot [][:" + _ymaxbound + "] '" + Path.GetFileName(yHistFile) + "' using 2:1 with filledcurves y1 lt rgb \"black\"");

            gnuplotWriterLarge.WriteLine("set xtics rotate by 0");
            gnuplotWriterLarge.WriteLine();

            // Density plot
            gnuplotWriterLarge.WriteLine("set origin 0.45, 0.45");
            gnuplotWriterSmall.WriteLine("set origin 0.0, 0.0");
            gnuplotWriterLarge.WriteLine("set size 0.5, 0.5");
            gnuplotWriterSmall.WriteLine("set size square 0.5, 1.0");
            xlabel = aNameFinal;
            gnuplotWriterLarge.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            ylabel = bNameFinal;
            gnuplotWriterLarge.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            title = "Heat Map of " + vsString;
            gnuplotWriterLarge.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterLarge.WriteLine("splot [:" + _xmaxbound + "] [:" + _ymaxbound + "] '" + Path.GetFileName(densityFile) + "'");
            gnuplotWriterSmall.WriteLine("splot [:" + _xmaxbound + "] [:" + _ymaxbound + "] '" + Path.GetFileName(densityFile) + "'");


            gnuplotWriterLarge.WriteLine();
            gnuplotWriterSmall.WriteLine();

            // Y histogram (unrotated)
            gnuplotWriterLarge.WriteLine("set origin 0.0, 0.0");
            gnuplotWriterLarge.WriteLine("set size 0.45, 0.45");
            xlabel = bNameFinal;
            gnuplotWriterLarge.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            ylabel = "Count";
            gnuplotWriterLarge.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            title = "Histogram of " + bNameFinal + " distances";
            gnuplotWriterLarge.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterLarge.WriteLine("plot [:" + _ymaxbound + "] []'" + Path.GetFileName(yHistFile) + "' with filledcurves x1 lt rgb \"black\"");


            gnuplotWriterLarge.WriteLine();

            // X histogram
            gnuplotWriterLarge.WriteLine("set origin 0.45, 0.0");
            gnuplotWriterSmall.WriteLine("set origin 0.5, 0.08");
            gnuplotWriterLarge.WriteLine("set size 0.45, 0.45");
            gnuplotWriterSmall.WriteLine("set size square 0.5, 0.85");
            xlabel = aNameFinal;
            gnuplotWriterLarge.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set xlabel \"" + xlabel + "\" textcolor rgbcolor \"black\"");
            ylabel = "Count";
            gnuplotWriterLarge.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set ylabel \"" + ylabel + "\" textcolor rgbcolor \"black\"");
            title = "Histogram of " + aNameFinal + " distances";
            gnuplotWriterLarge.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterSmall.WriteLine("set title \"" + title + "\" textcolor rgbcolor \"black\"");
            gnuplotWriterLarge.WriteLine("plot [:" + _xmaxbound + "] []'" + Path.GetFileName(xHistFile) + "' with filledcurves x1 lt rgb \"black\"");
            gnuplotWriterSmall.WriteLine("plot [:" + _xmaxbound + "] []'" + Path.GetFileName(xHistFile) + "' with filledcurves x1 lt rgb \"black\"");
            
            gnuplotWriterLarge.WriteLine();
            gnuplotWriterSmall.WriteLine();

            gnuplotWriterLarge.WriteLine("unset multiplot");
        }

       private static void GeneratePartialHistograms(Hashtable cellsForWholeSample, Hashtable cellsForSelectedClusters, Hashtable cellsForSelectedClustersInter,
            int rank, PartialMatrix<TDistance> myRowStripMatrixForA, PartialMatrix<TDistance> myRowStripMatrixForB, Block[] myBlocks, PartialMatrix<bool> myRowStripMatrixForDnormCut)
       {
            for (int i = 0; i < myBlocks.Length; ++i)
            {
                Block block = myBlocks[i];
                if ((rank == i) || (rank > i && !IsOdd(rank + i)) || (rank < i && IsOdd(rank + i)))
                {
                    // Interesting block for this process
                    if (rank == i)
                    {
                        // Diagonal block
                        for (int r = block.RowRange.StartIndex; r <= block.RowRange.EndIndex; ++r)
                        {
                            long l1 = _lengthCut > -1 ? _seqs[r].Count : -1;
                            for (int c = block.ColumnRange.StartIndex; c < r; ++c)
                            {
                                long l2 = _lengthCut > -1 ? _seqs[c].Count : -1;

                                if (_denomcutsenabled && myRowStripMatrixForDnormCut[r,c])
                                {
                                    continue;
                                }
                                
                                // Each pair in block
                                double x = _useTDistanceMax
                                               ? ((double) myRowStripMatrixForA[r, c])/TDistance.MaxValue
                                               : myRowStripMatrixForA[r, c];
                                double y = _useTDistanceMax
                                               ? ((double) myRowStripMatrixForB[r, c])/TDistance.MaxValue
                                               : myRowStripMatrixForB[r, c];

                                // Ignore x or y values greater than distcut when distcut is specified
                                if (_distcut > -1 && (x > _distcut || y > _distcut)) continue;

                                // Ignore if the corresponding two sequence lengths are not within the given lengthcut
                                if (_lengthCut > -1 && (Math.Abs(l1 - l2) > _lengthCut * ((l1 + l2) / 2.0))) continue;

                                // Perform transforms (no transform if transform method is -1 for the respective matrix)
                                x = Transform(x, _aTransfm, _aTransfp);
                                y = Transform(y, _bTransfm, _bTransfp);

                                UpdateCells(x, y, _xmaxWhole, _xminWhole, _ymaxWhole, _yminWhole, _deltaxWhole, _deltayWhole, cellsForWholeSample, r, c);

                                if (_useClusters)
                                {
                                    int rCnum = ((int) PnumToCnum[r]);
                                    int cCnum = ((int) PnumToCnum[c]);
                                    if (SelectedCnums.Contains(rCnum) && SelectedCnums.Contains(cCnum))
                                    {
                                        if (rCnum == cCnum)
                                        {
                                            // Intra cluster distances
                                            UpdateCells(x, y, _xmaxSelected, _xminSelected, _ymaxSelected, _yminSelected,
                                                        _deltaxSelected, _deltaySelected, cellsForSelectedClusters, r, c);
                                        }
                                        else
                                        {
                                            // Inter cluster distances
                                            UpdateCells(x, y, _xmaxSelectedInter, _xminSelectedInter, _ymaxSelectedInter,
                                                        _yminSelectedInter,
                                                        _deltaxSelectedInter, _deltaySelectedInter,
                                                        cellsForSelectedClustersInter, r, c);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // Non diagonal block
                        for (int r = block.RowRange.StartIndex; r <= block.RowRange.EndIndex; ++r)
                        {
                            long l1 = _lengthCut > -1 ? _seqs[r].Count : -1;
                            for (int c = block.ColumnRange.StartIndex; c <= block.ColumnRange.EndIndex; ++c)
                            {
                                long l2 = _lengthCut > -1 ? _seqs[c].Count : -1;

                                if (_denomcutsenabled && myRowStripMatrixForDnormCut[r, c])
                                {
                                    continue;
                                }

                                // Each pair in block
                                double x = _useTDistanceMax
                                              ? ((double)myRowStripMatrixForA[r, c]) / TDistance.MaxValue
                                              : myRowStripMatrixForA[r, c];
                                double y = _useTDistanceMax
                                               ? ((double)myRowStripMatrixForB[r, c]) / TDistance.MaxValue
                                               : myRowStripMatrixForB[r, c];

                                // Ignore x or y values greater than distcut when distcut is specified
                                if (_distcut > -1 && (x > _distcut || y > _distcut)) continue;

                                // Ignore if the corresponding two sequence lengths are not within the given lengthcut
                                if (_lengthCut > -1 && (Math.Abs(l1 - l2) > _lengthCut * ((l1 + l2) / 2.0))) continue;

                                // Perform transforms (no transform if transform method is -1 for the respective matrix)
                                x = Transform(x, _aTransfm, _aTransfp);
                                y = Transform(y, _bTransfm, _bTransfp);

                                UpdateCells(x, y, _xmaxWhole, _xminWhole, _ymaxWhole, _yminWhole, _deltaxWhole, _deltayWhole, cellsForWholeSample, r, c);

                                if (_useClusters)
                                {
                                    int rCnum = ((int) PnumToCnum[r]);
                                    int cCnum = ((int) PnumToCnum[c]);
                                    if (SelectedCnums.Contains(rCnum) && SelectedCnums.Contains(cCnum))
                                    {
                                        if (rCnum == cCnum)
                                        {
                                            // Intra cluster distances
                                            UpdateCells(x, y, _xmaxSelected, _xminSelected, _ymaxSelected, _yminSelected,
                                                        _deltaxSelected, _deltaySelected, cellsForSelectedClusters, r, c);
                                        }
                                        else
                                        {
                                            // Inter cluster distances
                                            UpdateCells(x, y, _xmaxSelectedInter, _xminSelectedInter, _ymaxSelectedInter,
                                                        _yminSelectedInter,
                                                        _deltaxSelectedInter, _deltaySelectedInter,
                                                        cellsForSelectedClustersInter, r, c);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private static double Transform(double val, int transfm, double transfp)
        {
            if (transfm == 10)
            {
                val = Math.Min(1.0, val);
                return Math.Pow(val, transfp);
            }
            return val;
        }

        private static void ReadDistanceBlocks(int rank, PartialMatrix<TDistance> myRowStripMatrixForA, PartialMatrix<TDistance> myRowStripMatrixForB, Block[] myColumnBlocks,
            double dnormcut, PartialMatrix<bool> myRowStripMatrixForDnormCut)
        {
#if USE_UINT16
            using (MatrixReader matReaderA = new MatrixReader(_aMat, MatrixType.UInt16, _size),
                                matReaderB = new MatrixReader(_bMat, MatrixType.UInt16, _size))
#elif USE_INT16
            using (MatrixReader matReaderA = new MatrixReader(_aMat, MatrixType.Int16, _size),
                                matReaderB = new MatrixReader(_bMat, MatrixType.Int16, _size))
#else
            using (MatrixReader matReaderA = new MatrixReader(_aMat, MatrixType.Double, _size),
                                matReaderB = new MatrixReader(_bMat, MatrixType.Double, _size))
#endif
            {
                MatrixReader oldScoreReader = null, newScoreReader = null;
                if (_denomcutsenabled)
                {
                    oldScoreReader = new MatrixReader(_oldscoremat, MatrixType.Int16, _size);
                    newScoreReader = new MatrixReader(_newscoremat, MatrixType.Int16, _size);
                }

                for (int i = 0; i < myColumnBlocks.Length; ++i)
                {
                    Block block = myColumnBlocks[i];
                    if ((rank == i) || (rank > i && !IsOdd(rank + i)) || (rank < i && IsOdd(rank + i)))
                    {
                        // Interesting block for this process
                        if (rank == i)
                        {
                            // Diagonal block
                            for (int r = block.RowRange.StartIndex; r <= block.RowRange.EndIndex; ++r) // block.RowRange should be equivalent to myRowStripMatrix's row range
                            {
                                long l1 = _lengthCut > -1 ? _seqs[r].Count : -1;
                                for (int c = block.ColumnRange.StartIndex; c < r; ++c)
                                {
                                    long l2 = _lengthCut > -1 ? _seqs[c].Count : -1;

                                    // Each pair in block
                                    TDistance tA = FromArrayToTdist(matReaderA.Read(r, c));
                                    TDistance tB = FromArrayToTdist(matReaderB.Read(r, c));
                                    myRowStripMatrixForA[r, c] = tA;
                                    myRowStripMatrixForB[r, c] = tB;

                                    if (_denomcutsenabled)
                                    {
                                        double oldscoredist = ((double)FromArrayToTdist(oldScoreReader.Read(r, c))) / TDistance.MaxValue;
                                        double newscoredist = ((double)FromArrayToTdist(newScoreReader.Read(r, c))) / TDistance.MaxValue;
                                        double newnormoveroldnorm = (1.0 - oldscoredist) / (1.0 - newscoredist);

                                        if (newnormoveroldnorm < 0) throw new Exception("Bad: negative ratio");

                                        myRowStripMatrixForDnormCut[r, c] = newnormoveroldnorm < dnormcut;

                                        if (myRowStripMatrixForDnormCut[r,c]) continue;
                                    }

                                    double x = _useTDistanceMax ? ((double) tA)/TDistance.MaxValue : tA;
                                    double y = _useTDistanceMax ? ((double) tB)/TDistance.MaxValue : tB;

                                    // Ignore x or y values greater than distcut when distcut is specified
                                    if (_distcut > -1 && (x > _distcut || y > _distcut)) continue;

                                    // Ignore if the corresponding two sequence lengths are not within the given lengthcut
                                    if (_lengthCut > -1 && (Math.Abs(l1 - l2) > _lengthCut * ((l1 + l2) / 2.0))) continue;

                                    // Perform transforms (no transform if transform method is -1 for the respective matrix)
                                    x = Transform(x, _aTransfm, _aTransfp);
                                    y = Transform(y, _bTransfm, _bTransfp);

                                    UpdateMinMax(x, y, ref _xmaxWhole, ref _xminWhole, ref _ymaxWhole, ref _yminWhole);

                                    if (_useClusters)
                                    {
                                        int rCnum = ((int) PnumToCnum[r]);
                                        int cCnum = ((int) PnumToCnum[c]);
                                        if (SelectedCnums.Contains(rCnum) && SelectedCnums.Contains(cCnum))
                                        {
                                            if (rCnum == cCnum)
                                            {
                                                // Intra cluster distances
                                                UpdateMinMax(x, y, ref _xmaxSelected, ref _xminSelected,
                                                             ref _ymaxSelected,
                                                             ref _yminSelected);
                                            }
                                            else
                                            {
                                                // Inter cluster distances
                                                UpdateMinMax(x, y, ref _xmaxSelectedInter, ref _xminSelectedInter,
                                                             ref _ymaxSelectedInter, ref _yminSelectedInter);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // Non diagonal block
                            for (int r = block.RowRange.StartIndex; r <= block.RowRange.EndIndex; ++r)
                            {
                                long l1 = _lengthCut > -1 ? _seqs[r].Count : -1;
                                for (int c = block.ColumnRange.StartIndex; c <= block.ColumnRange.EndIndex; ++c)
                                {
                                    long l2 = _lengthCut > -1 ? _seqs[c].Count : -1;

                                    // Each pair in block
                                    TDistance tA = FromArrayToTdist(matReaderA.Read(r, c));
                                    TDistance tB = FromArrayToTdist(matReaderB.Read(r, c));
                                    myRowStripMatrixForA[r, c] = tA;
                                    myRowStripMatrixForB[r, c] = tB;

                                    double x = _useTDistanceMax ? ((double)tA) / TDistance.MaxValue : tA;
                                    double y = _useTDistanceMax ? ((double)tB) / TDistance.MaxValue : tB;

                                    if (_denomcutsenabled)
                                    {
                                        double oldscoredist = ((double)FromArrayToTdist(oldScoreReader.Read(r, c))) / TDistance.MaxValue;
                                        double newscoredist = ((double)FromArrayToTdist(newScoreReader.Read(r, c))) / TDistance.MaxValue;
                                        double newnormoveroldnorm = (1.0 - oldscoredist) / (1.0 - newscoredist);

                                        if (newnormoveroldnorm < 0) throw new Exception("Bad: negative ratio");

                                        myRowStripMatrixForDnormCut[r, c] = newnormoveroldnorm < dnormcut;

                                        if (myRowStripMatrixForDnormCut[r, c]) continue;
                                    }

                                    // Ignore x or y values greater than distcut when distcut is specified
                                    if (_distcut > -1 && (x > _distcut || y > _distcut)) continue;

                                    // Ignore if the corresponding two sequence lengths are not within the given lengthcut
                                    if (_lengthCut > -1 && (Math.Abs(l1 - l2) > _lengthCut * ((l1 + l2) / 2.0))) continue;

                                    // Perform transforms (no transform if transform method is -1 for the respective matrix)
                                    x = Transform(x, _aTransfm, _aTransfp);
                                    y = Transform(y, _bTransfm, _bTransfp);

                                    UpdateMinMax(x, y, ref _xmaxWhole, ref _xminWhole, ref _ymaxWhole, ref _yminWhole);

                                    if (_useClusters)
                                    {
                                        int rCnum = ((int) PnumToCnum[r]);
                                        int cCnum = ((int) PnumToCnum[c]);
                                        if (SelectedCnums.Contains(rCnum) && SelectedCnums.Contains(cCnum))
                                        {
                                            if (rCnum == cCnum)
                                            {
                                                // Intra cluster distances
                                                UpdateMinMax(x, y, ref _xmaxSelected, ref _xminSelected,
                                                             ref _ymaxSelected,
                                                             ref _yminSelected);
                                            }
                                            else
                                            {
                                                // Inter cluster distances
                                                UpdateMinMax(x, y, ref _xmaxSelectedInter, ref _xminSelectedInter,
                                                             ref _ymaxSelectedInter, ref _yminSelectedInter);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (_denomcutsenabled)
                {
                    if (oldScoreReader != null) oldScoreReader.Dispose();
                    if (newScoreReader != null) newScoreReader.Dispose();
                }
            }
        }

        private static void UpdateMinMax(double x, double y, ref double xmax, ref double xmin, ref double ymax, ref double ymin)
        {
            if (x > xmax)
            {
                xmax = x;
            }

            if (x < xmin)
            {
                xmin = x;
            }

            if (y > ymax)
            {
                ymax = y;
            }

            if (y < ymin)
            {
                ymin = y;
            }
        }

        private static void UpdateCells(double x, double y, double xmax, double xmin, double ymax, double ymin,
            double deltax, double deltay, Hashtable cells, int r, int c)
        {
            // cell number based on zero index from bottom left corner
            // if x is equal to xmax then it's placed in the last cell, which is xres-1 in zero based index
            // same is done for y when y == ymax
            int cellx = x == xmax ? _xres - 1 : (int)Math.Floor((x - xmin) / deltax);
            int celly = y == ymax ? _yres - 1 : (int)Math.Floor((y - ymin) / deltay);

            if (x > xmax || y > ymax || x < xmin || y < ymin)
            {
                // now this should never be reached
                throw new Exception("bad(1)-> x: " + x + " y: " + y + " xmax: " + xmax + " xmin: " + xmin + " ymax: " +
                                    ymax + " ymin: " + ymin + "lengthcut: " + _lengthCut + " row: " + r + " col: " + c);
            }

            if (cellx >= _xres || celly >= _yres)
            {
                // now this should never be reached
                throw new Exception("bad(2)-> x: " + x + " y:" + y + " xmax: " + xmax + " xmin: " + xmin + " ymax: " +
                                    ymax + " ymin: " + ymin + " cellx: " + cellx + " celly: " + celly);
            }

            string cell = cellx + "," + celly;
            cells[cell] = cells.ContainsKey(cell) ? ((long)cells[cell]) + 1 : 1L;
        }

        private static TDistance FromArrayToTdist(byte[] xarr)
        {
#if USE_UINT16
           return BitConverter.ToUInt16(xarr, 0);
#elif USE_INT16
            return BitConverter.ToInt16(xarr, 0);
#else
           return BitConverter.ToDouble(xarr, 0);
#endif
        }

        private static void ReadConfiguration(Arguments pargs)
        {
            string config = pargs.GetValue<string>("config");
            
            /* Reading parameters file */
            using (StreamReader reader = new StreamReader(config))
            {
                char[] sep = new[] { ' ', '\t' };
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    // Skip null/empty and comment lines
                    if (!string.IsNullOrEmpty(line) && !line.StartsWith("#"))
                    {
                        string[] splits = line.Trim().Split(sep);
                        if (splits.Length >= 2)
                        {
                            string value = splits[1];
                            switch (splits[0])
                            {
                                case "Amat":
                                    _aMat = value;
                                    break;
                                case "Aname":
                                    _aName = value;
                                    break;
                                case "Atransfm":
                                    _aTransfm = int.Parse(value);
                                    break;
                                case "Atransfp":
                                    _aTransfp = double.Parse(value);
                                    break;
                                case "Bmat":
                                    _bMat = value;
                                    break;
                                case "Bname":
                                    _bName = value;
                                    break;
                                case "Btransfm":
                                    _bTransfm = int.Parse(value);
                                    break;
                                case "Btransfp":
                                    _bTransfp = double.Parse(value);
                                    break;
                                case "usetdistancemax":
                                    _useTDistanceMax = bool.Parse(value);
                                    break;
                                case "size":
                                    _size = int.Parse(value);
                                    break;
                                case "outdir":
                                    _outdir = value;
                                    break;
                                case "xmaxbound":
                                    _xmaxbound = double.Parse(value);
                                    break;
                                case "ymaxbound":
                                    _ymaxbound = double.Parse(value);
                                    break;
                                case "xres":
                                    _xres = int.Parse(value);
                                    break;
                                case "yres":
                                    _yres = int.Parse(value);
                                    break;
                                case "alpha":
                                    _alpha = double.Parse(value);
                                    break;
                                case "pcutf":
                                    _pcutf = double.Parse(value);
                                    break;
                                case "zto1":
                                    _zto1 = bool.Parse(value);
                                    break;
                                case "distcut":
                                    _distcut = double.Parse(value);
                                    break;
                                case "clusterfile":
                                    if (!"none".Equals(value) && File.Exists(value))
                                    {
                                        _clusterfile = value;
                                        _useClusters = true;
                                    }
                                    else
                                    {
                                        _useClusters = false;
                                    }
                                    break;
                                case "clusters":
                                    if (!"none".Equals(value) && value.Contains(","))
                                    {
                                        char[] commasep = new[] { ',' };
                                        foreach (int c in value.Trim().Split(commasep).Select(x => int.Parse(x)))
                                        {
                                            if (!SelectedCnums.Contains(c))
                                            {
                                                SelectedCnums.Add(c);
                                            }
                                        }
                                    }
                                    break;
                                case "title":
                                    _title = line.Substring(5).Trim();
                                    break;
                                case "seqfile":
                                    if (!"none".Equals(value) && File.Exists(value))
                                    {
                                        using (FastAParser parser = new FastAParser(value))
                                        {
                                            IEnumerable<ISequence> seqenum = parser.Parse();
                                            foreach (ISequence sequence in seqenum)
                                            {
                                                _seqs.Add(sequence);
                                            }
                                        }
                                    }
                                    break;
                                case "lengthcut":
                                    _lengthCut = double.Parse(value);
                                    break;
                                case "denomcuts":
                                    _denomcuts = value.Trim().Split(',').Select(x => double.Parse(x)).ToArray();
                                    _denomcutsenabled = !(_denomcuts.Length == 1 && _denomcuts[0] == -1);
                                        
                                    break;
                                case "oldscoremat":
                                    _oldscoremat = value;
                                    break;
                                case "newscoremat":
                                    _newscoremat = value;
                                    break;
                                default:
                                    throw new Exception("Invalide line in configuration file: " + line);
                            }
                        }
                        else
                        {
                            throw new Exception("Invalid line in configuration file: " + line);
                        }

                    }
                }
            }
        }

        private static bool IsOdd(int value)
        {
            return (value & 1) == 1;
        }
    }
}
